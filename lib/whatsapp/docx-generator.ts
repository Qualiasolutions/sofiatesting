import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
} from "docx";

/**
 * Parse text with bold markers (**text**) into segments
 */
interface TextSegment {
  text: string;
  bold: boolean;
}

function parseBoldText(line: string): TextSegment[] {
  const parts: TextSegment[] = [];
  const regex = /\*\*([^*]+)\*\*/g;
  let lastIndex = 0;
  let match;

  while ((match = regex.exec(line)) !== null) {
    // Add text before the match
    if (match.index > lastIndex) {
      const textBefore = line.slice(lastIndex, match.index);
      if (textBefore) {
        parts.push({ text: textBefore, bold: false });
      }
    }
    // Add the bold text
    parts.push({ text: match[1], bold: true });
    lastIndex = match.index + match[0].length;
  }

  // Add remaining text
  if (lastIndex < line.length) {
    parts.push({ text: line.slice(lastIndex), bold: false });
  }

  // If no parts were added, return the original line
  if (parts.length === 0) {
    parts.push({ text: line, bold: false });
  }

  return parts;
}

/**
 * Generate a DOCX document from text content
 *
 * Handles:
 * - Bold text (**text**)
 * - Line breaks
 * - Basic formatting
 */
export async function generateDocx(content: string): Promise<Buffer> {
  const lines = content.split("\n");
  const children: Paragraph[] = [];

  for (const line of lines) {
    // Skip empty lines but add spacing
    if (!line.trim()) {
      children.push(new Paragraph({ text: "" }));
      continue;
    }

    // Check if line is a header (starts with ** and ends with **)
    if (line.startsWith("**") && line.endsWith("**") && !line.includes("**", 2)) {
      // This is a title/header
      const headerText = line.replace(/^\*\*/, "").replace(/\*\*$/, "");
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: headerText,
              bold: true,
              size: 28, // 14pt
            }),
          ],
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 },
        })
      );
      continue;
    }

    // Handle lines with bold text mixed in
    if (line.includes("**")) {
      const segments = parseBoldText(line);
      children.push(
        new Paragraph({
          children: segments.map(
            (segment) =>
              new TextRun({
                text: segment.text,
                bold: segment.bold,
                size: 24, // 12pt
              })
          ),
          spacing: { after: 100 },
        })
      );
    } else {
      // Plain text line
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: line,
              size: 24, // 12pt
            }),
          ],
          spacing: { after: 100 },
        })
      );
    }
  }

  // Add footer with SOFIA branding
  children.push(new Paragraph({ text: "" }));
  children.push(new Paragraph({ text: "" }));
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: "Generated by SOFIA - Zyprus Property Group AI Assistant",
          italics: true,
          size: 20, // 10pt
          color: "888888",
        }),
      ],
      alignment: AlignmentType.CENTER,
    })
  );

  const doc = new Document({
    sections: [
      {
        properties: {
          page: {
            margin: {
              top: 1440, // 1 inch
              right: 1440,
              bottom: 1440,
              left: 1440,
            },
          },
        },
        children,
      },
    ],
  });

  return await Packer.toBuffer(doc);
}
